<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on November 29, 2011 by texi2html 1.82
texi2html was written by: 
            Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people.
Send bugs and suggestions to <texi2html-bug@nongnu.org>
-->
<head>
<title>GNU Go Documentation: 11. Tactical reading</title>

<meta name="description" content="GNU Go Documentation: 11. Tactical reading">
<meta name="keywords" content="GNU Go Documentation: 11. Tactical reading">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.82">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.roman {font-family:serif; font-weight:normal;}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Tactical-Reading"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="gnugo_10.html#DFA-Optimizations" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Reading-Basics" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="gnugo_10.html#DFA" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="gnugo.html#Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="gnugo_12.html#Pattern-Based-Reading" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="gnugo.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_22.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Tactical-reading"></a>
<h1 class="chapter">11. Tactical reading</h1>

<a name="index-Reading-code"></a>
<a name="index-Reading-process"></a>
<a name="index-Trying-hypothetical-moves"></a>
<a name="index-Usage-of-the-stack-in-reading"></a>
<a name="index-reading-DEPTH"></a>
<a name="index-Depth-of-reading"></a>
<a name="index-reading_002ec"></a>
<a name="index-reading_002eh"></a>

<p>The process of visualizing potential moves done by you and your
opponent to learn the result of different moves is called
&quot;reading&quot;. GNU Go does three distinct types of reading: <em>tactical
reading</em> which typically is concerned with the life and death of
individual strings, <em>Owl reading</em> which is concerned
with the life and death of dragons, and <em>connection reading</em>.
In this Chapter, we document
the tactical reading code, which is in &lsquo;<tt>engine/reading.c</tt>&rsquo;.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Reading-Basics">11.1 Reading Basics</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#Hashing">11.2 Hashing of Positions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                      Hashing of positions
</td></tr>
<tr><td align="left" valign="top"><a href="#Persistent-Cache">11.3 Persistent Reading Cache</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#Ko">11.4 Ko Handling</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                           Ko handling
</td></tr>
<tr><td align="left" valign="top"><a href="#A-Ko-Example">11.5 A Ko Example</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#Another-Ko-Example">11.6 Another Ko Example</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#Alternate-Komaster-Schemes">11.7 Alternate Komaster Schemes</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#Superstrings">11.8 Superstrings</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#Debugging">11.9 Debugging the reading code</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#Connection-Reading">11.10 Connection Reading</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
</table>

<hr size="6">
<a name="Reading-Basics"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Tactical-Reading" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Organization-of-the-reading-code" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Tactical-Reading" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Tactical-Reading" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="gnugo_12.html#Pattern-Based-Reading" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="gnugo.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_22.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Reading-Basics-1"></a>
<h2 class="section">11.1 Reading Basics</h2>

<p>What we call <em>Tactical Reading</em> is the analysis whether there is
a direct capture of a single string, or whether there is a move to prevent
such a direct capture.
</p>
<p>If the reading module finds out that the string can get captured, this
answer should (usually) be trusted. However, if it says it can be defended,
this does not say as much. It is often the case that such a string has
no chance to make a life, but that it cannot be captured within the
horizon (and the cutoff heuristics) of the tactical reading.
</p>
<p>The tactical reading is done by the functions in &lsquo;<tt>engine/reading.c</tt>&rsquo;.
It is a minimax search that declares win for the attacker once he can
physically take the string off board, whereas the defense is considered
successful when the string has sufficiently many liberties. A string with
five liberties is always considered alive. At higher depth within the
search tree even fewer liberties cause GNU Go to give up the attack,
See <a href="#depthparams">depthparams</a>.
</p>
<p>The reading code makes use of a stack onto which board positions can
be pushed. The parameter <code>stackp</code> is zero if GNU Go is
examining the true board position; if it is higher than zero, then
GNU Go is examining a hypothetical position obtained by playing
several moves.
</p>
<p>The most important public reading functions are <code>attack</code> and
<code>find_defense</code>. These are wrappers for functions <code>do_attack</code> and
<code>do_find_defense</code> which are declared statically in &lsquo;<tt>reading.c</tt>&rsquo;. The
functions <code>do_attack</code> and <code>do_find_defense</code> call each other
recursively.
</p>
<hr size="6">
<a name="Organization-of-the-reading-code"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Reading-Basics" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Return-Codes-1" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Tactical-Reading" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Reading-Basics" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="gnugo_12.html#Pattern-Based-Reading" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="gnugo.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_22.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection">11.1.1 Organization of the reading code</h3>

<p>The function <code>do_attack</code> and <code>do_find_defense</code> are wrappers
themselves and call <code>attack1</code>, <code>attack2</code>, <code>attack3</code> or
<code>attack4</code> resp.  <code>defend1</code>, <code>defend1</code>, <code>defend1</code>
or <code>defend1</code> depending on the number of liberties.
</p>
<p>These are fine-tuned to generate and try out the moves in an efficient
order. They generate a few moves themselves (mostly direct liberties
of the string), and then call helper functions called <code>..._moves</code> 
which suggest less obvious moves. Which of these functions get called
depends on the number of liberties and of the current search depth.
</p>
<hr size="6">
<a name="Return-Codes-1"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Organization-of-the-reading-code" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Reading-cutoff-and-depth-parameters" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Tactical-Reading" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Reading-Basics" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="gnugo_12.html#Pattern-Based-Reading" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="gnugo.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_22.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection">11.1.2 Return Codes</h3>
<p><a name="Return-Codes"></a>
<a name="index-return-codes"></a>
<a name="index-reading-return-codes"></a>
</p>
<p>The return codes of the reading (and owl) functions and owl can
be <code>0</code>, <code>KO_B</code>, <code>KO_A</code> or <code>WIN</code>. Each reading
function determines whether a particular player (assumed to have the
move) can solve a specific problem, typically attacking or defending
a string.
</p>
<p>A return code of <code>WIN</code> means success, 0 failure, while <code>KO_A</code> and
<code>KO_B</code> are success conditioned on ko. A function returns <code>KO_A</code>
if the position results in ko and that the player to move
will get the first ko capture (so the opponent has to make the
first ko threat). A return code of <code>KO_B</code> means that the player
to move will have to make the first ko threat.
</p>
<p><a name="Experimental-Owl-Extension"></a>
If GNU Go is compiled with the configure option
&lsquo;<samp>--enable-experimental-owl-ext</samp>&rsquo; then the owl functions also have
possible return codes of <code>GAIN</code> and <code>LOSS</code>. A code of <code>GAIN</code>
means that the attack (or defense) does not succeed, but that in the process
of trying to attack or defend, an opponent&rsquo;s worm is captured. A code
of <code>LOSS</code> means that the attack or defense succeeds, but that another
friendly worm dies during the attack or defense.
</p>
<hr size="6">
<a name="Reading-cutoff-and-depth-parameters"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Return-Codes-1" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Hashing" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Tactical-Reading" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Reading-Basics" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="gnugo_12.html#Pattern-Based-Reading" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="gnugo.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_22.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection">11.1.3 Reading cutoff and depth parameters</h3>
<p><a name="depthparams"></a>
</p>
<p>Depth of reading is controlled by the parameters <code>depth</code>
and <code>branch_depth</code>. The <code>depth</code> has a default value
<code>DEPTH</code> (in &lsquo;<tt>liberty.h</tt>&rsquo;), which is set to 16 in the
distribution, but it may also be set at the command line using
the &lsquo;<samp>-D</samp>&rsquo; or &lsquo;<samp>--depth</samp>&rsquo; option.  If <code>depth</code> is
increased, GNU Go will be stronger and slower. GNU Go will read
moves past depth, but in doing so it makes simplifying
assumptions that can cause it to miss moves.
</p>
<p>Specifically, when <code>stackp &gt; depth</code>, GNU Go assumes that as
soon as the string can get 3 liberties it is alive. This
assumption is sufficient for reading ladders.
</p>
<p>The <code>branch_depth</code> is typically set a little below <code>depth</code>.
Between <code>branch_depth</code> and <code>depth</code>, attacks on strings with
3 liberties are considered, but branching is inhibited, so fewer
variations are considered.
</p>
<p>%<a name="index-small_005fsemeai"></a>
%Currently the reading code does not try to defend a string by
%attacking a boundary string with more than two liberties. Because
%of this restriction, it can make oversights. A symptom of this is
%two adjacent strings, each having three or four liberties, each
%classified as <code>DEAD</code>. To resolve such situations, a function
%<code>small_semeai()</code> (in &lsquo;<tt>engine/semeai.c</tt>&rsquo;) looks for such
%pairs of strings and corrects their classification.
</p>
<p>The <code>backfill_depth</code> is a similar variable with a default 12. Below
this depth, GNU Go will try &quot;backfilling&quot; to capture stones.
For example in this situation:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">
.OOOOOO.    on the edge of the board, O can capture X but
OOXXXXXO    in order to do so he has to first play at a in
.aObX.XO    preparation for making the atari at b. This is
--------    called backfilling.

</pre></td></tr></table>

<p>Backfilling is only tried with <code>stackp &lt;= backfill_depth</code>. The
parameter <code>backfill_depth</code> may be set using the &lsquo;<samp>-B</samp>&rsquo;
option.
</p>
<p>The <code>fourlib_depth</code> is a parameter with a default of only 7.
Below this depth, GNU Go will try to attack strings with
four liberties. The <code>fourlib_depth</code> may be set using the
&lsquo;<samp>-F</samp>&rsquo; option.
</p>
<p>The parameter <code>ko_depth</code> is a similar cutoff. If
<code>stackp&lt;ko_depth</code>, the reading code will make experiments
involving taking a ko even if it is not legal to do so (i.e., it
is hypothesized that a remote ko threat is made and answered
before continuation).  This parameter may be set using the
&lsquo;<samp>-K</samp>&rsquo; option.
</p>
<a name="index-reading_002ec-1"></a>

<ul>
<li> <code>int attack(int str, int *move)</code>
<a name="index-attack"></a>
<blockquote><p>Determines if the string at <code>str</code> can
be attacked, and if so, <code>*move</code> returns the attacking move,
unless <code>*movei</code> is a null pointer. (Use null pointers if
you are interested in the result of the attack but not the
attacking move itself.) Returns <code>WIN</code>, if the attack succeeds,
0 if it fails, and <code>KO_A</code> or <code>KO_B</code> if the result depends on ko
<a href="#Return-Codes">Return Codes</a>.
</p></blockquote>
<a name="index-find_005fdefense"></a>
</li><li> <code>find_defense(int str, int *move)</code>
<blockquote><p>Attempts to find a move that will save the string at <code>str</code>. It
returns true if such a move is found, with <code>*move</code> the location
of the saving move (unless <code>*move</code> is a null pointer). It is not
checked that tenuki defends, so this may give an erroneous answer if
<code>!attack(str)</code>.  Returns <code>KO_A</code> or <code>KO_B</code> if the
result depends on ko See <a href="#Return-Codes">Return Codes</a>. 
</p></blockquote>
<a name="index-safe_005fmove"></a>
</li><li> <code>safe_move(int str, int color)</code> :
<blockquote><p>The function <code>safe_move(str, color)</code> checks whether a move at
<code>str</code> is illegal or can immediately be captured. If <code>stackp==0</code>
the result is cached. If the move only can be captured by a ko, it&rsquo;s
considered safe. This may or may not be a good convention.
</p></blockquote>
</li></ul>

<hr size="6">
<a name="Hashing"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Reading-cutoff-and-depth-parameters" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Hash-Calculation" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Tactical-Reading" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Tactical-Reading" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="gnugo_12.html#Pattern-Based-Reading" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="gnugo.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_22.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Hashing-of-Positions"></a>
<h2 class="section">11.2 Hashing of Positions</h2>

<a name="index-Hashing-of-positions"></a>
<a name="index-Reading-optimisation"></a>
<a name="index-Speedup-of-reading-process"></a>
<a name="index-Zobrist-hashing-algorithm"></a>
<a name="index-Transposition-table"></a>

<p>To speed up the reading process, we note that a position can be
reached in several different ways.  In fact, it is a very common
occurrence that a previously checked position is rechecked, often
within the same search but from a different branch in the recursion
tree. 
</p>
<p>This wastes a lot of computing resources, so in a number of places, we
store away the current position, the function we are in, and which worm
is under attack or to be defended.  When the search for this position
is finished, we also store away the result of the search and which
move made the attack or defense succeed.
</p>
<p>All this data is stored in a hash table, sometimes also called a
transposition table, where Go positions are the key and results of the
reading for certain functions and groups are the data. You can increase
the size of the Hash table using the &lsquo;<samp>-M</samp>&rsquo; or &lsquo;<samp>--memory</samp>&rsquo;
option see section <a href="gnugo_3.html#Invoking-GNU-Go">Invoking GNU Go: Command line options</a>.
</p>
<p>The hash table is created once and for all at the beginning of
the game by the function <code>hashtable_new()</code>. Although hash
memory is thus allocated only once in the game, the table is
reinitialized at the beginning of each move by a call to
<code>hashtable_clear()</code> from <code>genmove()</code>.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Hash-Calculation">11.2.1 Calculation of the hash value</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#Hash-Organization">11.2.2 Organization of the hash table</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#Hash-Structures">11.2.3 Hash Structures</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Structures in &lsquo;<tt>hash.h</tt>&rsquo;
</td></tr>
</table>

<hr size="6">
<a name="Hash-Calculation"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Hashing" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Hash-Organization" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Tactical-Reading" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Hashing" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="gnugo_12.html#Pattern-Based-Reading" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="gnugo.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_22.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Calculation-of-the-hash-value"></a>
<h3 class="subsection">11.2.1 Calculation of the hash value</h3>

<p>The hash algorithm is called Zobrist hashing, and is a standard
technique for go and chess programming. The algorithm as used by us
works as follows:
</p>
<a name="index-go-position"></a>
<a name="index-position"></a>

<ol>
<li> First we define a <em>go position</em>.  This positions consists of
<ul>
<li> the actual board, i.e. the locations and colors of the stones
</li><li> A <em>ko point</em>, if a ko is going on.  The ko point is defined as
the empty point where the last single stone was situated before
it was captured.
</li></ul>

<p>It is not necessary to specify the color to move (white or black)
as part of the position. The reason for this is that read results
are stored separately for the various reading functions such as
<code>attack3</code>, and it is implicit in the calling function which
player is to move.
</p>
</li><li> For each location on the board we generate random numbers:
<ul>
<li> A number which is used if there is a white stone on this location
</li><li> A number which is used if there is a black stone on this location
</li><li> A number which is used if there is a ko on this location
</li></ul>

<p>These random numbers are generated once at initialization time and
then used throughout the life time of the hash table.
</p>
</li><li> The hash key for a position is the XOR of all the random numbers
which are applicable for the position (white stones, black stones, and
ko position).
</li></ol>

<hr size="6">
<a name="Hash-Organization"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Hash-Calculation" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Hash-Structures" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Tactical-Reading" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Hashing" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="gnugo_12.html#Pattern-Based-Reading" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="gnugo.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_22.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Organization-of-the-hash-table"></a>
<h3 class="subsection">11.2.2 Organization of the hash table</h3>

<p>The hash table consists of 3 parts:
</p>
<a name="index-Hash-node"></a>
<a name="index-Read-result"></a>

<ul>
<li> An area which contains so called <em>Hash Nodes</em>. Each hash node
contains:
<ul class="toc">
<li>- A go position as defined above.
</li><li>- A computed hash value for the position
</li><li>- A pointer to Read Results (see below)
</li><li>- A pointer to another hash node.
</li></ul>

</li><li> An area with so called Read Results.  These are used to store
which function was called in the go position, which string was
under attack or to be defended, and the result of the reading.

<p>Each Read Result contains: 
</p><ul class="toc">
<li>- the function ID (an int between 0 and 255), the position of the
string under attack and a depth value, which is used to
determine how deep the search was when it was made, packed into
one 32 bit integer. 
</li><li>- The result of the search (a numeric value) and a position to
play to get the result packed into one 32 bit integer. 
</li><li>- A pointer to another Read Result.
</li></ul>

</li><li> An array of pointers to hash nodes.  This is the hash table
proper.

</li></ul>

<p>When the hash table is created, these 3 areas are allocated using
<code>malloc()</code>.  When the hash table is populated, all contents are taken
from the Hash nodes and the Read results. No further allocation is
done and when all nodes or results are used, the hash table is full.
Nothing is deleted from the hash table except when it is totally
emptied, at which point it can be used again as if newly initialized.
</p>
<a name="index-hashtable_005fsearch"></a>
<p>When a function wants to use the hash table, it looks up the current
position using <code>hashtable_search()</code>. If the position doesn&rsquo;t already
exist there, it can be entered using
</p>
<a name="index-hashtable_005fenter_005fposition"></a>
<p><code>hashtable_enter_position()</code>.  
</p>
<a name="index-hashtable_005fenter_005fposition-1"></a>
<p>Once the function has a pointer to the hash node containing a
function, it can search for a result of a previous search using
<code>hashnode_search()</code>.  If a result is found, it can be used, and
if not, a new result can be entered after a search using 
<a name="index-hashnode_005fnew_005fresult"></a>
<code>hashnode_new_result()</code>.
</p>
<p>Hash nodes which hash to the same position in the hash table
(collisions) form a simple linked list.  Read results for the same
position, created by different functions and different attacked or
defended strings also form a linked list.
</p>
<p>This is deemed sufficiently efficient for now, but the representation
of collisions could be changed in the future.  It is also not
determined what the optimum sizes for the hash table, the number of
positions and the number of results are.
</p>
<hr size="6">
<a name="Hash-Structures"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Hash-Organization" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Persistent-Cache" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Tactical-Reading" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Hashing" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="gnugo_12.html#Pattern-Based-Reading" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="gnugo.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_22.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Hash-Structures-1"></a>
<h3 class="subsection">11.2.3 Hash Structures</h3>

<p>The basic hash structures are declared in &lsquo;<tt>engine/hash.h</tt>&rsquo; and
&lsquo;<tt>engine/cache.c</tt>&rsquo;
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">typedef struct hashposition_t {
  Compacttype  board[COMPACT_BOARD_SIZE];
  int          ko_pos;
} Hashposition;
</pre></td></tr></table>

<p>Represents the board and optionally the location of a ko,
which is an illegal move. The player whose move is next
is not recorded.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">typedef struct {
  Hashvalue     hashval;
  Hashposition  hashpos;
} Hash_data;
</pre></td></tr></table>

<p>Represents the return value of a function (<code>hashval</code>) and
the board state (<code>hashpos</code>).
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">typedef struct read_result_t {
  unsigned int data1;	
  unsigned int data2;

  struct read_result_t *next;
} Read_result;
</pre></td></tr></table>

<p>The data1 field packs into 32 bits the following fields:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">
komaster:  2 bits (EMPTY, BLACK, WHITE, or GRAY)
kom_pos : 10 bits (allows MAX_BOARD up to 31)
routine :  4 bits (currently 10 different choices)
str1    : 10 bits
stackp  :  5 bits

</pre></td></tr></table>

<p>The data2 field packs into 32 bits the following fields:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">
status :   2 bits (0 free, 1 open, 2 closed)
result1:   4 bits
result2:   4 bits
move   :  10 bits
str2   :  10 bits

</pre></td></tr></table>

<p>The <code>komaster</code> and <code>(kom_pos)</code> field are
documented in See section <a href="#Ko">Ko Handling</a>.
</p>
<p>When a new result node is created, &rsquo;status&rsquo; is set to 1 &rsquo;open&rsquo;.
This is then set to 2 &rsquo;closed&rsquo; when the result is entered. The main
use for this is to identify open result nodes when the hashtable is
partially cleared. Another potential use for this field is to
identify repeated positions in the reading, in particular local
double or triple kos.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">typedef struct hashnode_t {
  Hash_data            key;
  Read_result        * results;
  struct hashnode_t  * next;
} Hashnode;
</pre></td></tr></table>

<p>The hash table consists of hash nodes.  Each hash node consists of
The hash value for the position it holds, the position itself and
the actual information which is purpose of the table from the start.
</p>
<p>There is also a pointer to another hash node which is used when
the nodes are sorted into hash buckets (see below).
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">typedef struct hashtable {
  size_t         hashtablesize;	/* Number of hash buckets */
  Hashnode    ** hashtable;	/* Pointer to array of hashnode lists */

  int            num_nodes;	/* Total number of hash nodes */
  Hashnode     * all_nodes;	/* Pointer to all allocated hash nodes. */
  int            free_node;	/* Index to next free node. */

  int            num_results;	/* Total number of results */
  Read_result  * all_results;	/* Pointer to all allocated results. */
  int            free_result;	/* Index to next free result. */
} Hashtable;
</pre></td></tr></table>

<p>The hash table consists of three parts:
</p>
<ul>
<li> The hash table proper: a number of hash buckets with collisions
being handled by a linked list.
</li><li> The hash nodes.  These are allocated at creation time and are 
never removed or reallocated in the current implementation.
</li><li> The results of the searches.  Since many different searches can
be done in the same position, there should be more of these than
hash nodes.
</li></ul>

<hr size="6">
<a name="Persistent-Cache"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Hash-Structures" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Ko" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Tactical-Reading" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Tactical-Reading" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="gnugo_12.html#Pattern-Based-Reading" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="gnugo.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_22.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Persistent-Reading-Cache"></a>
<h2 class="section">11.3 Persistent Reading Cache</h2>

<a name="index-persistent-cache"></a>
<a name="index-store_005fpersistent_005freading_005fcache"></a>
<a name="index-purge_005fpersistent_005freading_005fcache"></a>
<a name="index-purge_005fpersistent_005fconnection_005fcache"></a>
<a name="index-purge_005fpersistent_005fbreakin_005fcache"></a>
<a name="index-purge_005fpersistent_005fowl_005fcache"></a>

<a name="index-search_005fpersistent_005freading_005fcache"></a>
<a name="index-store_005fpersistent_005freading_005fcache-1"></a>

<p>Some calculations can be safely saved from move to move. If the
opponent&rsquo;s move is not close to our worm or dragon, we do not have to
reconsider the life or death of that group on the next move. So
the result is saved in a persistent cache. Persistent caches are used for
are used in the engine for several types of read results.
</p>
<ul>
<li> Tactical reading
</li><li> Owl reading
</li><li> Connection reading
</li><li> Breakin code
</li></ul>

<p>In this section we will discuss the persistent caching of tactical
reading but the same principles apply to the other persistent caches.
</p>
<p>Persistent caching is an important performance feature. However it
can lead to mistakes and debugging problems&mdash;situations where GNU
Go generates the right move during debugging but plays a wrong move
during a game. If you suspect a persistent cache effect you may
try loading the sgf file with the &lsquo;<samp>--replay</samp>&rsquo; option and see if the
mistake is repeated (see section <a href="gnugo_3.html#Invoking-GNU-Go">Invoking GNU Go: Command line options</a>).
</p>
<p>The function <code>store_persistent_cache()</code> is called only
by <code>attack</code> and <code>find_defense</code>, never from their
static recursive counterparts <code>do_attack</code> and <code>do_defend</code>.
The function <code>store_persistent_reading_cache()</code> attempts to
cache the most expensive reading results. The function
<code>search_persistent_reading_cache</code> attempts to retrieve a
result from the cache.
</p>
<p>If all cache entries are occupied, we try to replace the least useful
one. This is indicated by the score field, which is initially the
number of nodes expended by this particular reading, and later
multiplied by the number of times it has been retrieved from the
cache.
</p>
<p>Once a (permanent) move is made, a number of cache entries immediately become
invalid.  These are cleaned away by the function
<code>purge_persistent_reading_cache().</code> To have a criterion
for when a result may be purged, the function 
<code>store_persistent_cache()</code> computes the
<em>reading shadow</em> and <em>active area</em>. If a permanent
move is subsequently played in the active area, the cached
result is invalidated. We now explain this algorithm in detail.
</p>
<a name="index-reading-shadow"></a>

<p>The <em>reading shadow</em> is the concatenation of all moves in all
variations, as well as locations where an illegal move has been tried.
</p>
<p>Once the read is finished, the reading shadow is expanded
to the <em>active area</em> which may be cached. The 
intention is that as long as no stones are played in the
active area, the cached value may safely be used.
</p>
<p>Here is the algorithm used to compute the active area.
This algorithm is in the function <code>store_persistent_reading_cache()</code>.
The most expensive readings so far are stored in the persistent cache.
</p>
<ul>
<li>
The reading shadow and the string under attack are marked
with the character &lsquo;<samp>1</samp>&rsquo;. We also include the successful
move, which is most often a part of the reading shadow, but
sometimes not, for example with the function <code>attack1()</code>.

</li><li>
Next the reading shadow is expanded by marking strings and
empty vertices adjacent to the area marked &lsquo;<samp>1</samp>&rsquo; with
the character &lsquo;<samp>2</samp>&rsquo;.

</li><li>
Next vertices adjacent to empty vertices marked &lsquo;<samp>2</samp>&rsquo; are
labelled with the character &lsquo;<samp>3</samp>&rsquo;.

</li><li>
Next all vertices adjacent to previously marked vertices. These are
marked &lsquo;<samp>-1</samp>&rsquo; instead of the more logical &lsquo;<samp>4</samp>&rsquo; because it
is slightly faster to code this way.

</li><li>
If the stack pointer is &gt;0 we add the moves already played from the
moves stack with mark 4.
</li></ul>

<hr size="6">
<a name="Ko"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Persistent-Cache" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#A-Ko-Example" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Tactical-Reading" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Tactical-Reading" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="gnugo_12.html#Pattern-Based-Reading" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="gnugo.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_22.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Ko-Handling"></a>
<h2 class="section">11.4 Ko Handling</h2>

<p>The principles of ko handling are the same for tactical reading and
owl reading.
</p>
<p>We have already mentioned (see section <a href="#Reading-Basics">Reading Basics</a>) that GNU Go
uses a return code of <code>KO_A</code> or <code>KO_B</code> if the result depends on
ko. The return code of <code>KO_B</code> means that the position can be won
provided the player whose move calls the function can come up
with a sufficiently large ko threat. In order to verify this,
the function must simulate making a ko threat and having it
answered by taking the ko even if it is illegal. We call such an
experimental taking of the ko a <em>conditional</em> ko capture.
</p>
<p>Conditional ko captures are accomplished by the function <code>tryko()</code>.
This function is like <code>trymove()</code> except that
it does not require legality of the move in question.
</p>
<p>The static reading functions, and the global functions <code>do_attack</code>
and <code>do_find_defense</code> consult parameters <code>komaster</code>,
<code>kom_pos</code>, which are declared static in &lsquo;<tt>board.c</tt>&rsquo;. These mediate ko
captures to prevent the occurrence of infinite loops. During
reading, the komaster values are pushed and popped from a stack.
</p>
<p>Normally <code>komaster</code> is <code>EMPTY</code> but it can also be
&lsquo;<samp>BLACK</samp>&rsquo;, &lsquo;<samp>WHITE</samp>&rsquo;, <code>GRAY_BLACK</code>, <code>GRAY_WHITE</code> or
<code>WEAK_KO</code>. The komaster is set to <code>color</code> when <code>color</code> makes a
conditional ko capture. In this case <code>kom_pos</code> is set to the location of
the captured ko stone.
</p>
<p>If the opponent is komaster, the reading functions will not try to
take the ko at <code>kom_pos</code>. Also, the komaster is normally not
allowed to take another ko. The exception is a nested ko, characterized
by the condition that the captured ko stone is at distance 1 both
vertically and horizontally from <code>kom_pos</code>, which is the location
of the last stone taken by the komaster. Thus in this situation:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">
         .OX
         OX*X
        OmOX
         OO

</pre></td></tr></table>

<p>Here if &lsquo;<samp>m</samp>&rsquo; is the location of <code>kom_pos</code>, then the move at 
&lsquo;<samp>*</samp>&rsquo; is allowed.
</p>
<p>The rationale behind this rule is that in the case where there are
two kos on the board, the komaster cannot win both, and by becoming
komaster he has already chosen which ko he wants to win. But in the
case of a nested ko, taking one ko is a precondition to taking the
other one, so we allow this.
</p>
<p>If the komaster&rsquo;s opponent takes a ko, then both players have taken one ko. In
this case <code>komaster</code> is set to <code>GRAY_BLACK</code> or <code>GRAY_WHITE</code> and
after this further ko captures are even further restricted.
</p>
<p>If the ko at <code>kom_pos</code> is filled, then the komaster reverts to
<code>EMPTY</code>.
</p>
<p>In detail, the komaster scheme is as follows. Color &lsquo;<samp>O</samp>&rsquo; is to move.
This scheme is known as scheme 5 since in versions of GNU Go through
3.4, several different schemes were included.
</p>
<ul>
<li> 1. Komaster is EMPTY.
<ul class="toc">
<li>- 1a. Unconditional ko capture is allowed.
<blockquote><p>Komaster remains EMPTY if previous move was not a ko capture.
Komaster is set to WEAK_KO if previous move was a ko capture
and kom_pos is set to the old value of board_ko_pos.
</p></blockquote>
</li><li>- 1b) Conditional ko capture is allowed.
<blockquote><p>Komaster is set to O and kom_pos to the location of the ko, where a stone was
just removed.
</p></blockquote>
</li></ul>
</li><li> 2. Komaster is O:
<ul class="toc">
<li>- 2a) Only nested ko captures are allowed. Kom_pos is moved to the
new removed stone.
</li><li>- 2b) If komaster fills the ko at kom_pos then komaster reverts to
EMPTY.
</li></ul>
</li><li> 3. Komaster is X:
<blockquote><p>Play at kom_pos is not allowed. Any other ko capture
is allowed. If O takes another ko, komaster becomes GRAY_X.
</p></blockquote>
</li><li>  4. Komaster is GRAY_O or GRAY_X:
<blockquote><p>Ko captures are not allowed. If the ko at kom_pos is
filled then the komaster reverts to EMPTY.
</p></blockquote>
</li><li> 5. Komaster is WEAK_KO:
<ul class="toc">
<li>- 5a) After a non-ko move komaster reverts to EMPTY.
</li><li>- 5b) Unconditional ko capture is only allowed if it is nested ko capture.
<blockquote><p>Komaster is changed to WEAK_X and kom_pos to the old value of
board_ko_pos.
</p></blockquote>
</li><li>- 5c) Conditional ko capture is allowed according to the rules of 1b.
</li></ul>
</li></ul>

<hr size="6">
<a name="A-Ko-Example"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Ko" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Another-Ko-Example" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Tactical-Reading" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Tactical-Reading" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="gnugo_12.html#Pattern-Based-Reading" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="gnugo.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_22.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="A-Ko-Example-1"></a>
<h2 class="section">11.5 A Ko Example</h2>

<p>To see the komaster scheme in action, consider this position
from the file &lsquo;<tt>regressions/games/life_and_death/tripod9.sgf</tt>&rsquo;.
We recommend studying this example by examining the variation file
produced by the command:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">  gnugo -l tripod9.sgf --decide-dragon C3 -o vars.sgf
</pre></td></tr></table>

<p>In the lower left hand corner, there are kos at A2 and B4.
Black is unconditionally dead because if W wins either ko 
there is nothing B can do.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">
 8 . . . . . . . .
 7 . . O . . . . .
 6 . . O . . . . .
 5 O O O . . . . .
 4 O . O O . . . .
 3 X O X O O O O .
 2 . X X X O . . .
 1 X O . . . . . .
   A B C D E F G H

</pre></td></tr></table>

<p>This is how the komaster scheme sees this. B (i.e. X) starts by 
taking the ko at B4. W replies by taking the ko at A1. The board 
looks like this:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">
 8 . . . . . . . .
 7 . . O . . . . .
 6 . . O . . . . .
 5 O O O . . . . .
 4 O X O O . . . .
 3 X . X O O O O .
 2 O X X X O . . .
 1 . O . . . . . .
   A B C D E F G H

</pre></td></tr></table>

<p>Now any move except the ko recapture (currently illegal)
at A1 loses for B, so B retakes the ko and becomes komaster.
The board looks like this:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">
 8 . . . . . . . .         komaster: BLACK
 7 . . O . . . . .         kom_pos: A2
 6 . . O . . . . .
 5 O O O . . . . .
 4 O X O O . . . .
 3 X . X O O O O .
 2 . X X X O . . .
 1 X O . . . . . .
   A B C D E F G H

</pre></td></tr></table>

<p>W takes the ko at B3 after which the komaster is <code>GRAY</code> and
ko recaptures are not allowed.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">
 8 . . . . . . . .         komaster: GRAY
 7 . . O . . . . .         kom_pos: B4
 6 . . O . . . . .
 5 O O O . . . . .
 4 O . O O . . . .
 3 X O X O O O O .
 2 . X X X O . . .
 1 X O . . . . . .
   A B C D E F G H

</pre></td></tr></table>

<p>Since B is not allowed any ko recaptures, there is nothing
he can do and he is found dead. Thus the komaster scheme
produces the correct result.
</p>

<hr size="6">
<a name="Another-Ko-Example"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#A-Ko-Example" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Alternate-Komaster-Schemes" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Tactical-Reading" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Tactical-Reading" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="gnugo_12.html#Pattern-Based-Reading" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="gnugo.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_22.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Another-Ko-Example-1"></a>
<h2 class="section">11.6 Another Ko Example</h2>

<p>We now consider an example to show why the komaster is reset
to <code>EMPTY</code> if the ko is resolved in the komaster&rsquo;s favor. This
means that the ko is filled, or else that is becomes no longer
a ko and it is illegal for the komaster&rsquo;s opponent to play
there.
</p>
<p>The position resulting under consideration is in the file
&lsquo;<tt>regressions/games/ko5.sgf</tt>&rsquo;.  This is the position:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example"> . . . . . . O O 8
 X X X . . . O . 7
 X . X X . . O . 6
 . X . X X X O O 5
 X X . X . X O X 4
 . O X O O O X . 3
 O O X O . O X X 2
 . O . X O X X . 1
 F G H J K L M N
</pre></td></tr></table>

<p>We recommend studying this example by
examining the variation file produced by the command:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">gnugo -l ko5.sgf --quiet --decide-string L1 -o vars.sgf
</pre></td></tr></table>

<p>The correct resolution is that H1 attacks L1 unconditionally while K2
defends it with ko (code <code>KO_A</code>).
</p>
<p>After Black (X) takes the ko at K3, white can do nothing
but retake the ko conditionally, becoming komaster. B cannot
do much, but in one variation he plays at K4 and W takes
at H1. The following position results:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example"> . . . . . . O O 8
 X X X . . . O . 7
 X . X X . . O . 6
 . X . X X X O O 5
 X X . X X X O X 4
 . O X O O O X . 3
 O O X O . O X X 2
 . O O . O X X . 1
 F G H J K L M N
</pre></td></tr></table>

<p>Now it is important the &lsquo;<samp>O</samp>&rsquo; is no longer komaster. Were &lsquo;<samp>O</samp>&rsquo;
still komaster, he could capture the ko at N3 and there would be
no way to finish off B.
</p>

<hr size="6">
<a name="Alternate-Komaster-Schemes"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Another-Ko-Example" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Essentially-the-2_002e7_002e232-scheme_002e" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Tactical-Reading" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Tactical-Reading" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="gnugo_12.html#Pattern-Based-Reading" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="gnugo.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_22.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Alternate-Komaster-Schemes-1"></a>
<h2 class="section">11.7 Alternate Komaster Schemes</h2>

<p>The following alternate schemes have been proposed. It is assumed
that &lsquo;<samp>O</samp>&rsquo; is the player about to move.
</p>
<hr size="6">
<a name="Essentially-the-2_002e7_002e232-scheme_002e"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Alternate-Komaster-Schemes" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Revised-2_002e7_002e232-version" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Tactical-Reading" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Alternate-Komaster-Schemes" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="gnugo_12.html#Pattern-Based-Reading" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="gnugo.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_22.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection">11.7.1 Essentially the 2.7.232 scheme.</h3>

<ul>
<li> Komaster is EMPTY.
<ul class="toc">
<li>- Unconditional ko capture is allowed. Komaster remains EMPTY.
</li><li>- Conditional ko capture is allowed. Komaster is set to O and
<code>kom_pos</code> to the location of the ko, where a stone was
just removed.
</li></ul>
</li><li> Komaster is O:
<ul class="toc">
<li>- Conditional ko capture is not allowed.
</li><li>- Unconditional ko capture is allowed. Komaster parameters unchanged.
</li></ul>
</li><li> Komaster is X:
<ul class="toc">
<li>- Conditional ko capture is not allowed.
</li><li>- Unconditional ko capture is allowed except for a move at 
<code>kom_pos</code>. Komaster parameters unchanged.
</li></ul>
</li></ul>

<hr size="6">
<a name="Revised-2_002e7_002e232-version"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Essentially-the-2_002e7_002e232-scheme_002e" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Superstrings" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Tactical-Reading" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Alternate-Komaster-Schemes" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="gnugo_12.html#Pattern-Based-Reading" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="gnugo.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_22.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection">11.7.2 Revised 2.7.232 version</h3>

<ul>
<li> Komaster is EMPTY.
<ul class="toc">
<li>- Unconditional ko capture is allowed. Komaster remains EMPTY.
</li><li>- Conditional ko capture is allowed. Komaster is set to &lsquo;<samp>O</samp>&rsquo; and
<code>kom_pos</code> to the location of the ko, where a stone was
just removed.
</li></ul>
</li><li> Komaster is &lsquo;<samp>O</samp>&rsquo;:
<ul class="toc">
<li>- Ko capture (both kinds) is allowed only if after playing the move,
<code>is_ko(kom_pos, X)</code> returns false. In that case, 
<code>kom_pos</code> is updated to the new ko position, i.e. the stone
captured by this move.
</li></ul>
</li><li> Komaster is &lsquo;<samp>X</samp>&rsquo;:
<ul class="toc">
<li>- Conditional ko capture is not allowed.
</li><li>- Unconditional ko capture is allowed except for a move at 
<code>kom_pos</code>. Komaster parameters unchanged.
</li></ul>
</li></ul>

<hr size="6">
<a name="Superstrings"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Revised-2_002e7_002e232-version" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Debugging" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Tactical-Reading" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Tactical-Reading" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="gnugo_12.html#Pattern-Based-Reading" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="gnugo.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_22.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Superstrings-1"></a>
<h2 class="section">11.8 Superstrings</h2>

<p>A <em>superstring</em> is an extended string, where the extensions are
through the following kinds of connections:
</p>
<ol>
<li> Solid connections (just like ordinary string).
<table><tr><td>&nbsp;</td><td><pre class="example">  OO
</pre></td></tr></table>
</li><li> Diagonal connection or one space jump through an intersection
where an opponent move would be suicide or self-atari.
<table><tr><td>&nbsp;</td><td><pre class="example">  ...
  O.O
  XOX
  X.X
</pre></td></tr></table>
</li><li> Bamboo joint.
<table><tr><td>&nbsp;</td><td><pre class="example">  OO
  ..
  OO
</pre></td></tr></table>
</li><li> Diagonal connection where both adjacent intersections are empty.
<table><tr><td>&nbsp;</td><td><pre class="example">  .O
  O.
</pre></td></tr></table>
</li><li> Connection through adjacent or diagonal tactically captured stones.
Connections of this type are omitted when the superstring code is
called from &lsquo;<tt>reading.c</tt>&rsquo;, but included when the superstring code is
called from &lsquo;<tt>owl.c</tt>&rsquo;.
</li></ol>

<p>Like a dragon, a superstring is an amalgamation of strings, but it is
a much tighter organization of stones than a dragon, and its purpose
is different. Superstrings are encountered already in the tactical
reading because sometimes attacking or defending an element of the
superstring is the best way to attack or defend a string. This is
in contrast with dragons, which are ignored during tactical reading.
</p>
<hr size="6">
<a name="Debugging"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Superstrings" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Connection-Reading" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Tactical-Reading" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Tactical-Reading" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="gnugo_12.html#Pattern-Based-Reading" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="gnugo.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_22.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Debugging-the-reading-code"></a>
<h2 class="section">11.9 Debugging the reading code</h2>

<a name="index-How-to-debug-the-reading-code"></a>
<a name="index-Debugging-the-reading-code"></a>
<a name="index-Reading-code-debugging-tools"></a>

<p>The reading code searches for a path through the move tree to
determine whether a string can be captured. We have a tool for
investigating this with the &lsquo;<samp>--decidestring</samp>&rsquo; option. This may
be run with or without an output file.
</p>
<p>Simply running 
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">
<code>gnugo -t -l [input file name] -L [movenumber] --decidestring [location]</code>

</pre></td></tr></table>

<p>will run <code>attack()</code> to determine whether the string can be captured.
If it can, it will also run <code>find_defense()</code> to determine whether or
not it can be defended. It will give a count of the number of
variations read. The &lsquo;<samp>-t</samp>&rsquo; is necessary, or else GNU Go will not
report its findings.
</p>
<p>If we add &lsquo;<samp>-o <var>output file</var></samp>&rsquo; GNU Go will produce
an output file with all variations considered. The variations are
numbered in comments.
</p>
<p>This file of variations is not very useful without a way of
navigating the source code. This is provided with the GDB
source file, listed at the end. You can source this from GDB,
or just make it your GDB init file.
</p>
<a name="index-GDB-1"></a>

<p>If you are using GDB to debug GNU Go you may find it less
confusing to compile without optimization. The optimization
sometimes changes the order in which program steps are
executed. For example, to compile &lsquo;<tt>reading.c</tt>&rsquo; without optimization,
edit &lsquo;<tt>engine/Makefile</tt>&rsquo; to remove the string <code>-O2</code> from
the file, touch &lsquo;<tt>engine/reading.c</tt>&rsquo; and make. Note that the
Makefile is automatically generated and may get overwritten
later.
</p>
<p>If in the course of reading you need to analyze a result where
a function gets its value by returning a cached position from
the hashing code, rerun the example with the hashing turned off
by the command line option &lsquo;<samp>--hash 0</samp>&rsquo;. You should get the same
result. (If you do not, please send us a bug report.) Don&rsquo;t
run &lsquo;<samp>--hash 0</samp>&rsquo; unless you have a good reason to, since it 
increases the number of variations. 
</p>
<p>With the source file given at the end of this document loaded,
we can now navigate the variations. It is a good idea to use
cgoban with a small &lsquo;<samp>-fontHeight</samp>&rsquo;, so that the
variation window takes in a big picture. (You can resize the
board.)
</p>
<p>Suppose after perusing this file, we find that variation 17 is
interesting and we would like to find out exactly what is
going on here. 
</p>
<p>The macro &rsquo;jt n&rsquo; will jump to the n-th variation.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">
(gdb) set args -l [filename] -L [move number] --decidestring [location]
(gdb) tbreak main
(gdb) run
(gdb) jt 17

</pre></td></tr></table>

<p>will then jump to the location in question. 
</p>
<p>Actually the attack variations and defense variations are numbered
separately. (But <code>find_defense()</code> is only run if <code>attack()</code> succeeds,
so the defense variations may or may not exist.) It is redundant to
have to tbreak main each time. So there are two macros avar and dvar.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">
(gdb) avar 17

</pre></td></tr></table>

<p>restarts the program, and jumps to the 17-th attack variation.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">
(gdb) dvar 17

</pre></td></tr></table>

<p>jumps to the 17-th defense variation. Both variation sets are
found in the same sgf file, though they are numbered separately.
</p>
<p>Other commands defined in this file:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">
<a name="index-GNU-Go_0027s-GDB-commands"></a>
<code>dump</code> will print the move stack.
<code>nv</code> moves to the next variation
<code>ascii i j</code> converts (i,j) to ascii

#######################################################
###############      .gdbinit file      ###############
#######################################################

# this command displays the stack

define dump
set dump_stack()
end

# display the name of the move in ascii

define ascii
set gprintf(&quot;%o%m\n&quot;,$arg0,$arg1)
end

# display the all information about a dragon

define dragon
set ascii_report_dragon(&quot;$arg0&quot;)
end

define worm
set ascii_report_worm(&quot;$arg0&quot;)
end

# move to the next variation

define nv
tbreak trymove
continue
finish
next
end

# move forward to a particular variation

define jt
while (count_variations &lt; $arg0)
nv
end
nv
dump
end

# restart, jump to a particular attack variation

define avar
delete
tbreak sgffile_decidestring
run
tbreak attack
continue
jt $arg0
end

# restart, jump to a particular defense variation

define dvar
delete
tbreak sgffile_decidestring
run
tbreak attack
continue
finish
next 3
jt $arg0
end

</pre></td></tr></table>

<hr size="6">
<a name="Connection-Reading"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Debugging" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="gnugo_12.html#Pattern-Based-Reading" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Tactical-Reading" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Tactical-Reading" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="gnugo_12.html#Pattern-Based-Reading" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="gnugo.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_22.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Connection-Reading-1"></a>
<h2 class="section">11.10 Connection Reading</h2>

<p>GNU Go does reading to determine if strings can be connected.  The algorithms
for this are in &lsquo;<tt>readconnect.c</tt>&rsquo;. As with the reading code, the connection
code is not pattern based.
</p>
<p>The connection code is invoked by the engine through the functions:
</p>
<ul>
<li> <code>int string_connect(int str1, int str2, int *move)</code>
<a name="index-string_005fconnect"></a>
<blockquote><p>Returns <code>WIN</code> if <code>str1</code> and <code>str2</code> can be connected. 
</p></blockquote>
</li><li> <code>int disconnect(int str1, int str2, int *move)</code>
<a name="index-disconnect"></a>
<blockquote><p>Returns <code>WIN</code> if <code>str1</code> and <code>str2</code> can be disconnected. 
</p></blockquote>
</li></ul>

<p>To see the connection code in action, you may try the
following example.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">gnugo --quiet -l connection3.sgf --decide-connection M3/N7 -o vars.sgf
</pre></td></tr></table>

<p>(The file &lsquo;<tt>connection3.sgf</tt>&rsquo; is in &lsquo;<tt>regression/games</tt>&rsquo;.)
Examine the sgf file produced by this to see what kind of reading
is done by the functions <code>string_connect()</code> and
<code>string_disconnect()</code>, which are called by the function
<code>decide_connection</code>. 
</p>
<p>One use of the connection code is used is through the autohelper macros
<code>oplay_connect</code>, <code>xplay_connect</code>, <code>oplay_disconnect</code> and
<code>xplay_disconnect</code> which are used in the connection databases.
</p>

<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Tactical-Reading" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="gnugo_12.html#Pattern-Based-Reading" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="gnugo.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_22.html#Concept-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="gnugo_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>buildd user</em> on <em>November 29, 2011</em> using <a href="http://www.nongnu.org/texi2html/"><em>texi2html 1.82</em></a>.
 </font>
 <br>

</p>
</body>
</html>
